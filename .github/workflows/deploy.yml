name: Infrastructure Deploy

on:
  push:
    branches: [main, develop]
    paths:
      - 'k8s-manifests/**'
      - 'argocd/applications/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      sync_policy:
        description: 'ArgoCD sync policy'
        required: false
        default: 'automatic'
        type: choice
        options:
          - automatic
          - manual

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}

jobs:
  get-infrastructure-info:
    name: Get Infrastructure Info
    runs-on: ubuntu-latest
    outputs:
      cluster-name: ${{ steps.cluster-info.outputs.cluster-name }}
      cluster-zone: ${{ steps.cluster-info.outputs.cluster-zone }}
      cluster-region: ${{ steps.cluster-info.outputs.cluster-region }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v1
        with:
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Get cluster info from Terraform
        id: cluster-info
        env:
          GOOGLE_APPLICATION_CREDENTIALS: /tmp/gcp-key.json
        run: |
          # Determine environment based on branch or input
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENVIRONMENT="production"
          else
            ENVIRONMENT="staging"
          fi
          
          # Map environment names to Terraform directory names
          case $ENVIRONMENT in
            "staging")
              TERRAFORM_ENV="stage"
              ;;
            "production")
              TERRAFORM_ENV="prod"
              ;;
            *)
              echo "Unknown environment: $ENVIRONMENT"
              exit 1
              ;;
          esac
          
          echo "Getting cluster info for environment: $ENVIRONMENT (terraform dir: $TERRAFORM_ENV)"
          
          # Set up Google Application Default Credentials for Terraform
          echo "Setting up service account credentials for Terraform..."
          echo '${{ secrets.GCP_SA_KEY }}' | base64 -d > /tmp/gcp-key.json
          
          # Verify the credentials file was created
          if [ ! -f "/tmp/gcp-key.json" ]; then
            echo "‚ùå Failed to create credentials file"
            exit 1
          fi
          
          echo "‚úÖ Credentials file created successfully"
          
          # Check if the state bucket exists, if not create it
          BUCKET_NAME="${{ secrets.GCP_PROJECT_ID }}-terraform-state"
          echo "Checking if state bucket exists: $BUCKET_NAME"
          
          if ! gsutil ls -b gs://$BUCKET_NAME > /dev/null 2>&1; then
            echo "‚ö†Ô∏è State bucket does not exist. Setting up backend..."
            
            # Setup the backend first
            cd terraform/backend
            terraform init
            terraform apply -auto-approve \
              -var="project_id=${{ secrets.GCP_PROJECT_ID }}" \
              -var="region=us-central1"
            
            echo "‚úÖ Backend setup completed"
            cd ../..
          else
            echo "‚úÖ State bucket already exists"
            
            # Check if bucket is managed by Terraform
            cd terraform/backend
            terraform init
            
            # Try to import the existing bucket if it's not in state
            if ! terraform show | grep -q "google_storage_bucket.terraform_state"; then
              echo "üì¶ Importing existing bucket into Terraform state..."
              
              # Import the bucket
              if terraform import google_storage_bucket.terraform_state $BUCKET_NAME; then
                echo "‚úÖ Successfully imported bucket into Terraform state"
              else
                echo "‚ö†Ô∏è Could not import bucket, but it exists. This is okay for deployment."
              fi
              
              # Also try to import the state lock object if it exists
              if gsutil ls gs://$BUCKET_NAME/.terraform_lock > /dev/null 2>&1; then
                terraform import google_storage_bucket_object.state_lock $BUCKET_NAME/.terraform_lock 2>/dev/null || true
              fi
            else
              echo "‚úÖ Bucket is already managed by Terraform"
            fi
            
            cd ../..
          fi
          
          cd terraform/environments/${TERRAFORM_ENV}
          
          # Update the backend configuration with actual project ID
          sed -i "s/YOUR_PROJECT_ID/${{ secrets.GCP_PROJECT_ID }}/g" main.tf
          
          # Initialize Terraform with backend authentication
          echo "Initializing Terraform..."
          terraform init
          
          # Check if infrastructure exists by looking for outputs
          echo "Checking if infrastructure is deployed..."
          if terraform output > /dev/null 2>&1 && [ -n "$(terraform output -json | jq -r 'keys[]' 2>/dev/null)" ]; then
            echo "‚úÖ Infrastructure exists, retrieving cluster information..."
            
            CLUSTER_NAME=$(terraform output -raw kubernetes_cluster_name 2>/dev/null || echo "")
            CLUSTER_REGION=$(terraform output -raw kubernetes_cluster_region 2>/dev/null || echo "")
            
            if [ -n "$CLUSTER_NAME" ] && [ -n "$CLUSTER_REGION" ]; then
              echo "cluster-name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
              echo "cluster-region=${CLUSTER_REGION}" >> $GITHUB_OUTPUT
              echo "cluster-zone=${CLUSTER_REGION}" >> $GITHUB_OUTPUT
              
              echo "Cluster Name: ${CLUSTER_NAME}"
              echo "Cluster Region: ${CLUSTER_REGION}"
            else
              echo "‚ö†Ô∏è Cluster outputs are empty, infrastructure may need to be deployed"
              echo "cluster-name=" >> $GITHUB_OUTPUT
              echo "cluster-region=" >> $GITHUB_OUTPUT
              echo "cluster-zone=" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è No infrastructure found. This appears to be a fresh environment."
            echo "üí° Infrastructure will need to be deployed first before applications can be deployed."
            
            # Set empty outputs for downstream jobs
            echo "cluster-name=" >> $GITHUB_OUTPUT
            echo "cluster-region=" >> $GITHUB_OUTPUT
            echo "cluster-zone=" >> $GITHUB_OUTPUT
            
            echo "To deploy infrastructure, run:"
            echo "cd terraform/environments/${TERRAFORM_ENV}"
            echo "terraform plan"
            echo "terraform apply"
          fi

  validate-manifests:
    name: Validate Kubernetes Manifests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install kubeval
        run: |
          wget https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz
          tar xf kubeval-linux-amd64.tar.gz
          sudo mv kubeval /usr/local/bin

      - name: Validate manifests
        run: |
          echo "üîç Validating Kubernetes manifests..."
          find k8s-manifests/ -name "*.yaml" -o -name "*.yml" | \
            xargs kubeval --ignore-missing-schemas --skip-kinds=PodDisruptionBudget,HorizontalPodAutoscaler

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [get-infrastructure-info, validate-manifests]
    if: |
      (github.ref == 'refs/heads/develop' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v1
        with:
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials \
            ${{ needs.get-infrastructure-info.outputs.cluster-name }} \
            --region ${{ needs.get-infrastructure-info.outputs.cluster-region }}

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 \
            https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd

      - name: Login to ArgoCD
        run: |
          argocd login ${{ secrets.ARGOCD_SERVER }} \
            --username ${{ secrets.ARGOCD_USERNAME }} \
            --password ${{ secrets.ARGOCD_PASSWORD }} \
            --insecure

      - name: Update staging manifests
        run: |
          echo "üìù Updating staging manifests with commit SHA: ${{ github.sha }}"

          # Update image tags in staging manifests if they reference application images
          if [ -f "k8s-manifests/staging/deployment.yaml" ]; then
            # This is a placeholder - you would update actual image references here
            echo "Updated staging manifests for commit ${{ github.sha }}"
          fi

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if git diff --exit-code k8s-manifests/staging/; then
            echo "No changes to commit in staging manifests"
          else
            git add k8s-manifests/staging/
            git commit -m "Update staging manifests for ${{ github.sha }}"
            git push
          fi

      - name: Sync ArgoCD application
        run: |
          echo "üöÄ Syncing staging application in ArgoCD"

          SYNC_POLICY="${{ github.event.inputs.sync_policy || 'automatic' }}"

          if [ "$SYNC_POLICY" = "automatic" ]; then
            argocd app sync bro-ai-staging --prune
            argocd app wait bro-ai-staging --timeout 600
          else
            echo "Manual sync requested - application will need to be synced manually in ArgoCD UI"
            argocd app get bro-ai-staging
          fi

      - name: Check application health
        run: |
          echo "üè• Checking application health"
          argocd app get bro-ai-staging

          # Wait for application to be healthy
          timeout 300 bash -c 'until argocd app get bro-ai-staging | grep -q "Health Status:.*Healthy"; do echo "Waiting for app to be healthy..."; sleep 10; done' || {
            echo "‚ùå Application failed to become healthy within timeout"
            argocd app get bro-ai-staging
            exit 1
          }

          echo "‚úÖ Staging deployment successful"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [get-infrastructure-info, validate-manifests]
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v1
        with:
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials \
            ${{ needs.get-infrastructure-info.outputs.cluster-name }} \
            --region ${{ needs.get-infrastructure-info.outputs.cluster-region }}

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 \
            https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd

      - name: Login to ArgoCD
        run: |
          argocd login ${{ secrets.ARGOCD_SERVER }} \
            --username ${{ secrets.ARGOCD_USERNAME }} \
            --password ${{ secrets.ARGOCD_PASSWORD }} \
            --insecure

      - name: Update production manifests
        run: |
          echo "üìù Updating production manifests with commit SHA: ${{ github.sha }}"

          # Update image tags in production manifests if they reference application images
          if [ -f "k8s-manifests/production/deployment.yaml" ]; then
            # This is a placeholder - you would update actual image references here
            echo "Updated production manifests for commit ${{ github.sha }}"
          fi

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if git diff --exit-code k8s-manifests/production/; then
            echo "No changes to commit in production manifests"
          else
            git add k8s-manifests/production/
            git commit -m "Update production manifests for ${{ github.sha }}"
            git push
          fi

      - name: Sync ArgoCD application
        run: |
          echo "üöÄ Syncing production application in ArgoCD"

          SYNC_POLICY="${{ github.event.inputs.sync_policy || 'manual' }}"

          if [ "$SYNC_POLICY" = "automatic" ]; then
            argocd app sync bro-ai-production --prune
            argocd app wait bro-ai-production --timeout 600
          else
            echo "‚ö†Ô∏è Manual sync policy - production deployment requires manual approval in ArgoCD UI"
            echo "Application status:"
            argocd app get bro-ai-production
            exit 0
          fi

      - name: Run smoke tests
        if: github.event.inputs.sync_policy == 'automatic'
        run: |
          echo "üß™ Running production smoke tests"

          # Get the external IP of the production service
          EXTERNAL_IP=$(kubectl get service bro-ai-service -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "")

          if [ -n "$EXTERNAL_IP" ]; then
            echo "Testing health endpoint at $EXTERNAL_IP"

            # Test health endpoint
            for i in {1..5}; do
              if curl -f "http://$EXTERNAL_IP/health" > /dev/null 2>&1; then
                echo "‚úÖ Health check passed"
                break
              else
                echo "‚ùå Health check failed, attempt $i/5"
                if [ $i -eq 5 ]; then
                  echo "All health checks failed"
                  exit 1
                fi
                sleep 10
              fi
            done
          else
            echo "‚ö†Ô∏è No external IP found for smoke tests"
          fi

      - name: Check application health
        run: |
          echo "üè• Checking production application health"
          argocd app get bro-ai-production

          # Wait for application to be healthy if auto-sync was used
          if [ "${{ github.event.inputs.sync_policy }}" = "automatic" ]; then
            timeout 300 bash -c 'until argocd app get bro-ai-production | grep -q "Health Status:.*Healthy"; do echo "Waiting for app to be healthy..."; sleep 10; done' || {
              echo "‚ùå Application failed to become healthy within timeout"
              argocd app get bro-ai-production
              exit 1
            }
            echo "‚úÖ Production deployment successful"
          fi

  notify-deployment:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    steps:
      - name: Determine deployment status
        run: |
          if [ "${{ needs.deploy-staging.result }}" = "success" ] || [ "${{ needs.deploy-production.result }}" = "success" ]; then
            echo "DEPLOYMENT_STATUS=success" >> $GITHUB_ENV
            echo "DEPLOYMENT_MESSAGE=‚úÖ Infrastructure deployment completed successfully" >> $GITHUB_ENV
          elif [ "${{ needs.deploy-staging.result }}" = "failure" ] || [ "${{ needs.deploy-production.result }}" = "failure" ]; then
            echo "DEPLOYMENT_STATUS=failure" >> $GITHUB_ENV
            echo "DEPLOYMENT_MESSAGE=‚ùå Infrastructure deployment failed" >> $GITHUB_ENV
          else
            echo "DEPLOYMENT_STATUS=skipped" >> $GITHUB_ENV
            echo "DEPLOYMENT_MESSAGE=‚è≠Ô∏è Infrastructure deployment was skipped" >> $GITHUB_ENV
          fi

      - name: Send Slack notification
        if: env.DEPLOYMENT_STATUS != 'skipped'
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"${{ env.DEPLOYMENT_MESSAGE }}\",
              \"blocks\": [
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"${{ env.DEPLOYMENT_MESSAGE }}\\n\\n*Repository:* ${{ github.repository }}\\n*Branch:* ${{ github.ref_name }}\\n*Commit:* \`${{ github.sha }}\`\\n*Workflow:* ${{ github.workflow }}\"
                  }
                }
              ]
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true
